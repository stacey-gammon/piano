#!/usr/bin/env python3
"""
Music CLI Tool - Audio processing and looping
"""

import argparse
import subprocess
import sys
import os
import glob
import tempfile
from pathlib import Path

# Beat detection imports
import numpy as np
import librosa
import soundfile as sf
BEAT_DETECTION_AVAILABLE = True

def detect_beats_and_tempo(audio_file, start_time=None, end_time=None):
    """Detect beats, downbeats, and tempo using librosa"""
    if not BEAT_DETECTION_AVAILABLE:
        print("Error: Beat detection libraries not available. Install with: pip install librosa soundfile")
        return None
    
    try:
        # Load audio file
        y, sr = librosa.load(audio_file, sr=None)
        
        # If time range specified, trim the audio
        if start_time is not None and end_time is not None:
            start_sample = int(start_time * sr)
            end_sample = int(end_time * sr)
            y = y[start_sample:end_sample]
        
        # Detect tempo and beats
        tempo, beats = librosa.beat.beat_track(y=y, sr=sr, units='time')
        
        # Convert beat times to samples for downbeat detection
        beat_samples = librosa.time_to_samples(beats, sr=sr)
        
        # Detect downbeats using onset strength
        onset_env = librosa.onset.onset_strength(y=y, sr=sr)
        # Use a simple approach: every 4th beat is a downbeat (assuming 4/4 time)
        downbeats = beats[::4]  # Every 4th beat
        
        return {
            'tempo': tempo,
            'beats': beats,
            'downbeats': downbeats,
            'sample_rate': sr,
            'duration': len(y) / sr
        }
    except Exception as e:
        print(f"Error detecting beats: {e}")
        return None

def create_metronome_click(tempo, duration, sample_rate=44100, click_volume=0.3):
    """Create a metronome click sound"""
    # Create a short click sound (sine wave with envelope)
    click_duration = 0.1  # 100ms click
    click_samples = int(click_duration * sample_rate)
    
    # Generate click frequency (higher pitch for downbeats)
    click_freq = 1000  # 1kHz
    
    # Create click envelope (quick attack, quick decay)
    t = np.linspace(0, click_duration, click_samples)
    envelope = np.exp(-t * 20)  # Quick decay
    
    # Generate click sound
    click = np.sin(2 * np.pi * click_freq * t) * envelope * click_volume
    
    return click

def add_fixed_tempo_metronome(input_file, tempo, output_file, start_time=None, end_time=None):
    """Add fixed tempo metronome clicks to audio file"""
    if not BEAT_DETECTION_AVAILABLE:
        print("Error: Beat detection libraries not available")
        return False
    
    try:
        # Load original audio
        y, sr = librosa.load(input_file, sr=None)
        
        # If time range specified, trim the audio
        if start_time is not None and end_time is not None:
            start_sample = int(start_time * sr)
            end_sample = int(end_time * sr)
            y = y[start_sample:end_sample]
        
        # Calculate beat interval in samples
        beat_interval = 60.0 / tempo  # seconds per beat
        beat_interval_samples = int(beat_interval * sr)
        
        # Create metronome track
        metronome = np.zeros_like(y)
        
        # Add regular metronome clicks
        current_beat = 0
        beat_sample = 0
        
        while beat_sample < len(y):
            # Create click
            click = create_metronome_click(tempo, 0.1, sr)
            click_end = min(beat_sample + len(click), len(y))
            click_len = click_end - beat_sample
            
            # Stronger click for downbeats (every 4th beat)
            if current_beat % 4 == 0:
                click = create_metronome_click(tempo, 0.15, sr, click_volume=0.5)
                click_end = min(beat_sample + len(click), len(y))
                click_len = click_end - beat_sample
            
            metronome[beat_sample:click_end] += click[:click_len]
            
            # Move to next beat
            current_beat += 1
            beat_sample += beat_interval_samples
        
        # Mix original audio with metronome
        mixed_audio = y + metronome
        
        # Normalize to prevent clipping
        max_val = np.max(np.abs(mixed_audio))
        if max_val > 1.0:
            mixed_audio = mixed_audio / max_val
        
        # Save the result
        sf.write(output_file, mixed_audio, sr)
        return True
        
    except Exception as e:
        print(f"Error adding fixed tempo metronome: {e}")
        return False

def add_downbeats_only_metronome(input_file, beat_info, output_file, start_time=None, end_time=None):
    """Add only downbeat clicks to audio file"""
    if not BEAT_DETECTION_AVAILABLE:
        print("Error: Beat detection libraries not available")
        return False
    
    try:
        # Load original audio
        y, sr = librosa.load(input_file, sr=None)
        
        # If time range specified, trim the audio
        if start_time is not None and end_time is not None:
            start_sample = int(start_time * sr)
            end_sample = int(end_time * sr)
            y = y[start_sample:end_sample]
        
        # Create metronome track
        metronome = np.zeros_like(y)
        
        # Add only downbeat clicks (stronger and more prominent)
        for downbeat_time in beat_info['downbeats']:
            downbeat_sample = int(downbeat_time * sr)
            if downbeat_sample < len(y):
                # Strong click for downbeats only
                click = create_metronome_click(beat_info['tempo'], 0.2, sr, click_volume=0.6)
                click_end = min(downbeat_sample + len(click), len(y))
                click_len = click_end - downbeat_sample
                metronome[downbeat_sample:click_end] += click[:click_len]
        
        # Mix original audio with metronome
        mixed_audio = y + metronome
        
        # Normalize to prevent clipping
        max_val = np.max(np.abs(mixed_audio))
        if max_val > 1.0:
            mixed_audio = mixed_audio / max_val
        
        # Save the result
        sf.write(output_file, mixed_audio, sr)
        return True
        
    except Exception as e:
        print(f"Error adding downbeats metronome: {e}")
        return False

def add_metronome_to_audio(input_file, beat_info, output_file, start_time=None, end_time=None):
    """Add metronome clicks to audio file at detected beat positions"""
    if not BEAT_DETECTION_AVAILABLE:
        print("Error: Beat detection libraries not available")
        return False
    
    try:
        # Load original audio
        y, sr = librosa.load(input_file, sr=None)
        
        # If time range specified, trim the audio
        if start_time is not None and end_time is not None:
            start_sample = int(start_time * sr)
            end_sample = int(end_time * sr)
            y = y[start_sample:end_sample]
        
        # Create metronome track
        metronome = np.zeros_like(y)
        
        # Add clicks at beat positions
        for beat_time in beat_info['beats']:
            beat_sample = int(beat_time * sr)
            if beat_sample < len(y):
                click = create_metronome_click(beat_info['tempo'], 0.1, sr)
                click_end = min(beat_sample + len(click), len(y))
                click_len = click_end - beat_sample
                metronome[beat_sample:click_end] += click[:click_len]
        
        # Add stronger clicks at downbeat positions
        for downbeat_time in beat_info['downbeats']:
            downbeat_sample = int(downbeat_time * sr)
            if downbeat_sample < len(y):
                # Stronger click for downbeats
                click = create_metronome_click(beat_info['tempo'], 0.15, sr, click_volume=0.5)
                click_end = min(downbeat_sample + len(click), len(y))
                click_len = click_end - downbeat_sample
                metronome[downbeat_sample:click_end] += click[:click_len]
        
        # Mix original audio with metronome
        mixed_audio = y + metronome
        
        # Normalize to prevent clipping
        max_val = np.max(np.abs(mixed_audio))
        if max_val > 1.0:
            mixed_audio = mixed_audio / max_val
        
        # Save the result
        sf.write(output_file, mixed_audio, sr)
        return True
        
    except Exception as e:
        print(f"Error adding metronome: {e}")
        return False

def export_with_beats(input_file, output_file, start_time=None, end_time=None, downbeats_only=False):
    """Export audio file with metronome overlay"""
    if not BEAT_DETECTION_AVAILABLE:
        print("Error: Beat detection libraries not available. Install with: pip install librosa soundfile")
        return False
    
    print(f"Exporting {input_file} with metronome overlay...")
    print("Analyzing audio for beats and tempo...")
    
    # Detect beats on the full song (or specified range)
    beat_info = detect_beats_and_tempo(input_file, start_time, end_time)
    
    if not beat_info:
        print("Beat detection failed")
        return False
    
    tempo = float(beat_info['tempo'].item()) if hasattr(beat_info['tempo'], 'item') else float(beat_info['tempo'])
    print(f"Detected tempo: {tempo:.1f} BPM")
    print(f"Found {len(beat_info['beats'])} beats")
    print(f"Found {len(beat_info['downbeats'])} downbeats")
    print(f"Duration: {beat_info['duration']:.1f} seconds")
    
    # Add metronome overlay
    if downbeats_only:
        print("Adding downbeat clicks only...")
        success = add_downbeats_only_metronome(input_file, beat_info, output_file, start_time, end_time)
    else:
        print("Adding all beat clicks...")
        success = add_metronome_to_audio(input_file, beat_info, output_file, start_time, end_time)
    
    if success:
        print(f"Exported with metronome overlay: {output_file}")
        return True
    else:
        print("Failed to add metronome overlay")
        return False

def cleanup_old_temp_files():
    """Clean up any leftover temporary files from previous runs"""
    tmp_dir = Path("tmp")
    if tmp_dir.exists():
        # Remove old temp files (older than 1 hour)
        import time
        current_time = time.time()
        for file_path in tmp_dir.glob("*"):
            if file_path.is_file() and (current_time - file_path.stat().st_mtime) > 3600:
                try:
                    file_path.unlink()
                except:
                    pass

def parse_time(time_str):
    """Parse time string like ':10' or '1:30' into seconds"""
    if time_str.startswith(':'):
        # Just seconds
        return float(time_str[1:])
    elif ':' in time_str:
        # Minutes:seconds
        parts = time_str.split(':')
        return float(parts[0]) * 60 + float(parts[1])
    else:
        # Just seconds
        return float(time_str)

def extract_audio(input_file, start_time, end_time, output_file=None):
    """Extract audio segment using ffmpeg"""
    if output_file is None:
        # Create output filename based on input
        input_path = Path(input_file)
        output_file = f"{input_path.stem}_extract_{start_time}s-{end_time}s{input_path.suffix}"
    
    # Ensure tmp directory exists
    tmp_dir = Path("tmp")
    tmp_dir.mkdir(exist_ok=True)
    
    # If output_file is a temp file, put it in tmp directory
    if output_file.startswith("temp_") or output_file.startswith("looped_"):
        output_file = tmp_dir / output_file
    
    duration = end_time - start_time
    
    # Always re-encode for segment extraction to avoid corruption issues
    # This is especially important for MP3 files which don't handle stream copy well
    cmd = [
        'ffmpeg',
        '-i', input_file,
        '-ss', str(start_time),
        '-t', str(duration),
        '-y',  # Overwrite output file
        output_file
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode == 0:
        print(f"Extracted audio segment: {output_file}")
        return str(output_file)
    else:
        print(f"Error extracting audio: {result.stderr}")
        return None

def loop_audio(input_files, start_time=None, end_time=None, add_beats=False):
    """Loop audio using streaming approach - supports multiple files"""
    temp_files = []
    
    # Ensure tmp directory exists
    tmp_dir = Path("tmp")
    tmp_dir.mkdir(exist_ok=True)
    
    try:
        # Parse input files (comma-separated)
        if isinstance(input_files, str):
            file_list = [f.strip() for f in input_files.split(',')]
        else:
            file_list = [input_files]
        
        print(f"Looping {len(file_list)} audio file(s): {', '.join(file_list)}")
        
        # Beat detection and metronome overlay
        if add_beats and BEAT_DETECTION_AVAILABLE:
            print("\n=== BEAT DETECTION ===")
            print("Analyzing audio for beats and tempo...")
            
            # Use the first file for beat detection
            main_file = file_list[0]
            beat_info = detect_beats_and_tempo(main_file, start_time, end_time)
            
            if beat_info:
                tempo = float(beat_info['tempo'].item()) if hasattr(beat_info['tempo'], 'item') else float(beat_info['tempo'])
                print(f"Detected tempo: {tempo:.1f} BPM")
                print(f"Found {len(beat_info['beats'])} beats")
                print(f"Found {len(beat_info['downbeats'])} downbeats")
                print(f"Duration: {beat_info['duration']:.1f} seconds")
                
                # Create metronome overlay
                print("Adding metronome clicks...")
                metronome_file = tmp_dir / f"metronome_{os.getpid()}.wav"
                temp_files.append(str(metronome_file))
                
                if add_metronome_to_audio(main_file, beat_info, str(metronome_file), start_time, end_time):
                    print(f"Metronome overlay saved to: {metronome_file}")
                    # Use the metronome file for looping instead of original
                    file_list[0] = str(metronome_file)
                else:
                    print("Failed to add metronome overlay, using original audio")
            else:
                print("Beat detection failed, using original audio")
        elif add_beats and not BEAT_DETECTION_AVAILABLE:
            print("Warning: Beat detection requested but libraries not available")
            print("Install with: pip install librosa soundfile")
        
        print("\nPress Ctrl+C to stop...")
        
        # Stream directly to ffplay without creating large files
        print("Starting looped audio stream...")
        
        if len(file_list) == 1:
            # Single file - stream loop directly
            input_file = file_list[0]
            if start_time is not None and end_time is not None:
                # For time segments, create a temporary file first, then loop it
                duration = end_time - start_time
                temp_file = tmp_dir / f"temp_segment_{os.getpid()}.wav"
                temp_files.append(str(temp_file))
                
                # First extract the segment
                extract_cmd = [
                    'ffmpeg',
                    '-i', input_file,
                    '-ss', str(start_time),
                    '-t', str(duration),
                    '-f', 'wav',
                    '-acodec', 'pcm_s16le',
                    '-ar', '44100',
                    '-ac', '2',
                    '-y',  # Overwrite
                    str(temp_file)
                ]
                
                print("Extracting segment...")
                extract_result = subprocess.run(extract_cmd, capture_output=True, text=True)
                if extract_result.returncode != 0:
                    print(f"Error extracting segment: {extract_result.stderr}")
                    return False
                
                # Now loop the extracted segment
                cmd = [
                    'ffmpeg',
                    '-stream_loop', '-1',  # Loop infinitely
                    '-i', str(temp_file),
                    '-f', 'wav',
                    '-acodec', 'pcm_s16le',
                    '-ar', '44100',
                    '-ac', '2',
                    '-'
                ]
            else:
                # Stream entire file loop
                cmd = [
                    'ffmpeg',
                    '-stream_loop', '-1',  # Loop infinitely
                    '-i', input_file,
                    '-f', 'wav',
                    '-acodec', 'pcm_s16le',
                    '-ar', '44100',
                    '-ac', '2',
                    '-'
                ]
        else:
            # Multiple files - create a temporary concatenated file first, then loop it
            concat_file = tmp_dir / f"concat_{os.getpid()}.wav"
            
            # First, create the concatenated version
            inputs = []
            filters = []
            
            for i, file_path in enumerate(file_list):
                inputs.extend(['-i', file_path])
                if start_time is not None and end_time is not None:
                    filters.append(f'[{i}:a]atrim=start={start_time}:end={end_time}[a{i}]')
                else:
                    filters.append(f'[{i}:a]acopy[a{i}]')
            
            # Concatenate all segments
            concat_inputs = ''.join([f'[a{i}]' for i in range(len(file_list))])
            filters.append(f'{concat_inputs}concat=n={len(file_list)}:v=0:a=1[out]')
            
            concat_cmd = [
                'ffmpeg'
            ] + inputs + [
                '-filter_complex', ';'.join(filters),
                '-map', '[out]',
                '-f', 'wav',
                '-acodec', 'pcm_s16le',
                '-ar', '44100',
                '-ac', '2',
                '-y',
                str(concat_file)
            ]
            
            print("Creating concatenated version...")
            concat_result = subprocess.run(concat_cmd, capture_output=True, text=True)
            
            if concat_result.returncode != 0:
                print(f"Error creating concatenated version: {concat_result.stderr}")
                return False
            
            # Now stream loop the concatenated file
            cmd = [
                'ffmpeg',
                '-stream_loop', '-1',  # Loop infinitely
                '-i', str(concat_file),
                '-f', 'wav',
                '-acodec', 'pcm_s16le',
                '-ar', '44100',
                '-ac', '2',
                '-'
            ]
        
        # Stream directly to ffplay (which supports stdin)
        ffmpeg_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        player = subprocess.Popen(['ffplay', '-nodisp', '-'], stdin=ffmpeg_process.stdout)
        
        # Close the stdout of ffmpeg to allow it to receive a SIGPIPE if ffplay stops
        ffmpeg_process.stdout.close()
        
        # Wait for user to stop
        try:
            player.wait()
        except KeyboardInterrupt:
            pass
        
    except KeyboardInterrupt:
        print("\nStopping loop...")
    finally:
        # Clean up processes
        try:
            if 'player' in locals() and player and player.poll() is None:
                player.terminate()
        except:
            pass
        
        try:
            if 'ffmpeg_process' in locals() and ffmpeg_process and ffmpeg_process.poll() is None:
                ffmpeg_process.terminate()
        except:
            pass
        
        # Clean up temp files
        for temp_file in temp_files:
            if os.path.exists(temp_file):
                os.remove(temp_file)
        if 'concat_file' in locals() and os.path.exists(concat_file):
            os.remove(concat_file)
    
    return True

def download_audio(url, output_format='mp3', quality='192K', output_dir='.'):
    """Download audio from YouTube URL using yt-dlp"""
    print(f"Downloading audio from: {url}")
    print(f"Format: {output_format}, Quality: {quality}")
    print(f"Output directory: {output_dir}")
    
    # Ensure output directory exists
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    
    # Use yt-dlp command line (more reliable than Python API)
    cmd = [
        'python3', '-m', 'yt_dlp',
        '--no-check-certificate',
        '--extract-audio',
        '--audio-format', output_format,
        '--audio-quality', quality,
        '--output', f'{output_dir}/%(title)s.%(ext)s',
        url
    ]
    
    # Run the command
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode == 0:
        print("Download completed successfully!")
        print(result.stdout)
        return True
    else:
        print("Error occurred during download:")
        print(result.stderr)
        return False

def split_audio(input_file):
    """Split audio into vocals and no_vocals using Demucs"""
    input_path = Path(input_file)
    
    if not input_path.exists():
        print(f"Error: File '{input_file}' not found")
        return False
    
    print(f"Splitting audio: {input_file}")
    print("This may take a few minutes...")
    
    # Use demucs command line (more reliable than Python API)
    # Try to use the virtual environment Python if available
    python_cmd = sys.executable
    if Path("py/music_env/bin/python").exists():
        python_cmd = str(Path("py/music_env/bin/python").absolute())
    elif Path("music_env/bin/python").exists():
        python_cmd = str(Path("music_env/bin/python").absolute())
    
    cmd = [
        python_cmd, "-m", "demucs",
        "--two-stems", "vocals",  # Separate vocals and accompaniment
        "--out", "outputs",  # Output directory
        str(input_path)
    ]
    
    # Run the command
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode == 0:
        print("Audio splitting completed successfully!")
        
        # Find the output files and rename them
        input_stem = input_path.stem
        input_suffix = input_path.suffix
        
        # Demucs creates a folder structure like: outputs/htdemucs/song_name/
        demucs_output_dir = Path("outputs") / "htdemucs" / input_stem
        
        if demucs_output_dir.exists():
            vocals_file = demucs_output_dir / "vocals.wav"
            no_vocals_file = demucs_output_dir / "no_vocals.wav"
            
            # Create new filenames in the same directory as input
            output_dir = input_path.parent
            vocals_output = output_dir / f"{input_stem}_only_vocals{input_suffix}"
            no_vocals_output = output_dir / f"{input_stem}_no_vocals{input_suffix}"
            
            # Convert and move files
            if vocals_file.exists():
                convert_cmd = [
                    'ffmpeg', '-i', str(vocals_file), '-y', str(vocals_output)
                ]
                subprocess.run(convert_cmd, capture_output=True)
                print(f"Vocals saved as: {vocals_output}")
            
            if no_vocals_file.exists():
                convert_cmd = [
                    'ffmpeg', '-i', str(no_vocals_file), '-y', str(no_vocals_output)
                ]
                subprocess.run(convert_cmd, capture_output=True)
                print(f"No vocals saved as: {no_vocals_output}")
            
            # Clean up the demucs output directory
            import shutil
            shutil.rmtree("outputs", ignore_errors=True)
            
        return True
    else:
        print("Error occurred during splitting:")
        print(result.stderr)
        return False

def main():
    # Clean up old temp files on startup
    cleanup_old_temp_files()
    
    parser = argparse.ArgumentParser(description='Music CLI Tool')
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Extract command
    extract_parser = subparsers.add_parser('extract', help='Extract audio segment')
    extract_parser.add_argument('input_file', help='Input audio file')
    extract_parser.add_argument('--start', required=True, help='Start time (e.g., :10 or 1:30)')
    extract_parser.add_argument('--end', required=True, help='End time (e.g., :30 or 2:00)')
    extract_parser.add_argument('--output', help='Output file (optional)')
    
    # Loop command
    loop_parser = subparsers.add_parser('loop', help='Loop audio (supports multiple files separated by commas)')
    loop_parser.add_argument('input_files', help='Input audio file(s) - use commas to separate multiple files')
    loop_parser.add_argument('--start', help='Start time (e.g., :10 or 1:30)')
    loop_parser.add_argument('--end', help='End time (e.g., :30 or 2:00)')
    loop_parser.add_argument('--beats', action='store_true', help='Add metronome clicks at detected beats and downbeats')
    
    # Download command
    download_parser = subparsers.add_parser('download', help='Download audio from YouTube URL')
    download_parser.add_argument('url', help='YouTube URL to download')
    download_parser.add_argument('--format', default='mp3', help='Output format (default: mp3)')
    download_parser.add_argument('--quality', default='192K', help='Audio quality (default: 192K)')
    download_parser.add_argument('--output-dir', default='.', help='Output directory (default: current directory)')
    
    # Split command
    split_parser = subparsers.add_parser('split', help='Split audio into vocals and no_vocals using Demucs')
    split_parser.add_argument('input_file', help='Input audio file to split')
    
    # Export with beats command
    export_parser = subparsers.add_parser('export-beats', help='Export audio with metronome overlay')
    export_parser.add_argument('input_file', help='Input audio file')
    export_parser.add_argument('--output', help='Output file (default: input_file_with_beats.wav)')
    export_parser.add_argument('--start', help='Start time (e.g., :10 or 1:30)')
    export_parser.add_argument('--end', help='End time (e.g., :30 or 2:00)')
    export_parser.add_argument('--downbeats-only', action='store_true', help='Only add downbeat clicks (every 4th beat)')
    
    args = parser.parse_args()
    
    if args.command == 'extract':
        start_time = parse_time(args.start)
        end_time = parse_time(args.end)
        
        if start_time >= end_time:
            print("Error: Start time must be before end time")
            sys.exit(1)
        
        extract_audio(args.input_file, start_time, end_time, args.output)
        
    elif args.command == 'loop':
        start_time = None
        end_time = None
        
        if args.start and args.end:
            start_time = parse_time(args.start)
            end_time = parse_time(args.end)
            
            if start_time >= end_time:
                print("Error: Start time must be before end time")
                sys.exit(1)
        
        loop_audio(args.input_files, start_time, end_time, args.beats)
    
    elif args.command == 'download':
        download_audio(args.url, args.format, args.quality, args.output_dir)
    
    elif args.command == 'split':
        split_audio(args.input_file)
    
    elif args.command == 'export-beats':
        start_time = None
        end_time = None
        
        if args.start and args.end:
            start_time = parse_time(args.start)
            end_time = parse_time(args.end)
            
            if start_time >= end_time:
                print("Error: Start time must be before end time")
                sys.exit(1)
        
        # Generate output filename if not provided
        if args.output:
            output_file = args.output
        else:
            input_path = Path(args.input_file)
            output_file = f"{input_path.stem}_with_beats.wav"
        
        export_with_beats(args.input_file, output_file, start_time, end_time, args.downbeats_only)
        
    else:
        parser.print_help()

if __name__ == '__main__':
    main()